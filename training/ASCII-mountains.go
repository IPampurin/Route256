/*
Условие задачи
Назовём рельефом гор 2D-изображение из n строк и m столбцов, состоящее только из символов X, . (точка), / (прямой слеш) и \ (обратный слеш).
Изображение составлено по следующим формальным правилам:
• либо непосредственно слева снизу от символа / находится такой же символ, либо непосредственно слева от символа /
 находится символ \, либо символ / находится на нижней строке;
• либо непосредственно справа сверху от символа / находится такой же символ, либо непосредственно справа от символа /
 находится символ \;
• либо непосредственно слева сверху от символа \ находится такой же символ, либо непосредственно слева от символа \
 находится символ /;
• либо непосредственно справа снизу от символа \ находится такой же символ, либо непосредственно справа от символа \
 находится символ /, либо символ \ находится на нижней строке;
• каждый столбец содержит не более одного из символов / и \;
• в каждом столбце все символы ниже / и \ равны X;
• все остальные символы равны ..

Все символы, кроме ., являются частью горы.
В каждом рельефе гор есть хотя бы один символ, не равный ..

Дано k рельефов по их близости к наблюдателю: от ближних к дальним. Выведите рельеф, видный наблюдателю. Если в некотором рельефе символ в
x-й строке и y-м столбце является частью горы, то во всех более дальних от наблюдателя рельефах гор символы на этой позиции не видны наблюдателю.

Входные данные
Каждый тест состоит из нескольких наборов входных данных. Первая строка содержит целое число (1≤t≤20) — количество наборов входных данных.
Далее следует описание наборов входных данных.
Первая строка каждого набора содержит три целых числа k, n и m (1≤k,n≤20, 2≤m≤20) — количество рельефов, высоту и ширину ASCII-арта.
Далее следуют описания k рельефов гор. Описание рельефа гор состоит из n строк, по m символов в каждой — сам ASCII-арт.
Описания рельефов разделены пустой строкой.

Выходные данные
Для каждого набора входных данных выведите в n строках рельеф гор, видный наблюдателю. После ответа на каждый набор входных данных выведите пустую строку.

Пример теста 1
Входные данные

3
2 6 18
..................
..................
.../\.............
../XX\/\../\......
./XXXXXX\/XX\.....
/XXXXXXXXXXXX\....

........../\......
........./XX\.....
......../XXXX\....
.../\../XXXXXX\...
../XX\/XXXXXXXX\..
./XXXXXXXXXXXXXX\.
1 2 2
..
/\
3 4 5
.....
.....
.....
./\..

.....
.....
./\..
/XX\.

.....
.....
../\.
./XX\
Выходные данные

........../\......
........./XX\.....
.../\.../XXXX\....
../XX\/\XX/\XX\...
./XXXXXX\/XX\XX\..
/XXXXXXXXXXXX\XX\.

..
/\

.....
.....
./\\.
//\\\

*/

package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
)

// outputing выводит результат
func outputing(out *bufio.Writer, arr [][]string, n, m int) {

	for i := 0; i < n; i++ {
		for j := 0; j < m; j++ {
			fmt.Fprintf(out, "%s", arr[i][j])
		}
		fmt.Fprint(out, "\n")
	}
}

// initBackground пишет фон арта
func initBackground(n, m int) [][]string {

	back := make([][]string, n, n)
	for i := 0; i < n; i++ {
		back[i] = make([]string, m, m)
		for j := 0; j < m; j++ {
			back[i][j] = "."
		}
	}

	return back
}

func main() {

	scanner := bufio.NewScanner(os.Stdin)
	scanner.Split(bufio.ScanLines)

	out := bufio.NewWriter(os.Stdout)
	defer out.Flush()

	// определяем количество групп входных данных
	scanner.Scan()
	t, err := strconv.Atoi(scanner.Text())
	if err != nil {
		log.Fatal(err)
	}

	// считываем ответы по группам
	for group := 1; group <= t; group++ {

		// определяем размеры арта (k, n, m)
		scanner.Scan()
		reliefNM := strings.Split(scanner.Text(), " ")
		relief, err := strconv.Atoi(reliefNM[0])
		if err != nil {
			log.Fatal(err)
		}
		n, err := strconv.Atoi(reliefNM[1])
		if err != nil {
			log.Fatal(err)
		}
		m, err := strconv.Atoi(reliefNM[2])
		if err != nil {
			log.Fatal(err)
		}

		// заполняем фон картинки
		background := initBackground(n, m)

		// для каждого рельефа по порядку
		for r := 1; r <= relief; r++ {

			// построчно считываем входные данные
			for i := 0; i < n; i++ {
				// считываем строку с описанием и переписываем элементы background, если это необходимо
				scanner.Scan()
				for j, value := range scanner.Text() {
					if background[i][j] == "." {
						background[i][j] = string(value)
					}
				}
			}

			// после вычитывания очередного рельефа пропускаем строку, если рельеф не крайний
			if r < relief {
				scanner.Scan()
			}
		}

		// выводим результат по группе данных
		outputing(out, background, n, m)
		// пропускаем строку между выводом по группам
		fmt.Fprint(out, "\n")
	}
}
