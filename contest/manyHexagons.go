/*
Условие задачи
В Nozo разрабатывается новая компьютерная игра — «Колонизация 8». Вам поручено реализовать генератор карт для этой игры.
Карта игры состоит из шестиугольников, которыми можно полностью покрыть бесконечную плоскость, и пустых пространств.
Персонажи могут передвигаться только по шестиугольникам. Шестиугольники могут находиться как полностью отдельно друг от друга,
так и иметь общие стороны, но не могут накладываться друг на друга.
Экран игрока имеет прямоугольную форму и состоит из множества точек — n точек в высоту и m точек в ширину.
В каждой точке может быть либо пробел (« »), либо один из символов, представляющий границы шестиугольника:
прямой слеш «/», обратный слеш «\» или нижнее подчёркивание «_». Выстраивая эти символы в правильной последовательности, можно собрать карту из шестиугольников.
Границы шестиугольников изображаются символами «_», «/», «\». Размер шестиугольника определяется двумя параметрами:
width – количество символов «_» на верхней и нижней сторонах шестиугольника;
height – количество прямых «/» или обратных «\» слешей на каждой из четырёх боковых сторон шестиугольника.
В этой задаче вам дан размер экрана игрока m (ширина) и n (высота), размеры шестиугольника width и height, а также количество шестиугольников k.
Вам нужно вывести карту размера m×n, на которой размещено k шестиугольников, каждый шириной width и высотой height.
При этом некоторые символы самого левого верхнего шестиугольника должны занимать первую строку и первый столбец экрана.
Если между шестиугольниками есть пустые пространства, должна быть возможность разбить их на шестиугольники такого же размера.
Также нужно, чтобы в получившемся экране была возможность заменить некоторые пробелы на символы «/», «\» и «_» так, чтобы получилась регулярная сетка из шестиугольников.

Входные данные
В единственной строке дано пять натуральных чисел через пробел: m,n,width,height,k (3≤m,n≤500), 1≤width≤m−2, 1≤height≤(n/2).
Гарантируется, что на поле n×m можно разместить не менее k шестиугольников шириной width и высотой height каждый.
Гарантируется, что n×m не больше 5000.

Выходные данные
Выведите в ответе один экран. Экран должен состоять из n+2 строк, каждая из которых содержит по m+2 символов.
Первая и последняя строки должны иметь формат «+---...---+», где количество символов «-» равно m.
Остальные строки экрана должны начинаться и заканчиваться символом «|», остальные символы на экране – « », «_», «/» или «\».
На экране должно быть k шестиугольников, каждый из которых имеет ширину width и высоту height.
Шестиугольники могут находиться на экране отдельно друг от друга или иметь одну или несколько общих сторон, но не могут накладываться друг на друга.
Каждый шестиугольник должен целиком находиться в пределах экрана.

Пример теста 1
Входные данные: 20 5 1 1 10
Выходные данные
+--------------------+
| _   _   _   _   _  |
|/ \_/ \_/ \_/ \_/ \ |
|\_/ \_/ \_/ \_/ \_/ |
|/ \_/ \_/ \_/ \_/   |
|\_/                 |
+--------------------+

Пример теста 2
Входные данные: 30 10 4 2 6
Выходные данные
+------------------------------+
|  ____        ____            |
| /    \      /    \           |
|/      \____/      \____      |
|\      /    \      /    \     |
| \____/      \____/      \    |
| /    \      /    \      /    |
|/      \____/      \____/     |
|\      /    \      /          |
| \____/      \____/           |
|                              |
+------------------------------+
*/

package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
)

var HexField [][]string
var Display [][]string

// inputing считывает введённые данные
func inputing(sc *bufio.Scanner) (int, int, int, int, int) {

	// считываем ввод
	sc.Scan()
	input := strings.Split(sc.Text(), " ")
	// парсим входные данные
	// экран в ширину
	m, err := strconv.Atoi(input[0])

	// экран в высоту
	n, err := strconv.Atoi(input[1])

	// основание шестиугольника
	width, err := strconv.Atoi(input[2])

	// полувысота шестиугольника
	height, err := strconv.Atoi(input[3])

	// общее количество шестиугольников
	k, err := strconv.Atoi(input[4])

	if err != nil {
		log.Fatal(err)
	}

	return m, n, width, height, k
}

// completeHexField рисует один шестиугольник на минимальном поле
func completeHexField(width, height int) {

	// подсчитываем размеры поля под один шестиугольник
	nField := 2*height + 1
	mField := 2*height + width

	// HexField поле, в рамках которого рисуется один шестиугольник
	HexField = make([][]string, nField, nField)

	// prefix отступ от левой и правой границ поля hexField
	prefix := height + 1

	// заполняем массив hexField символами так, чтобы получился шестиугольник
	for i := 0; i < len(HexField); i++ {

		HexField[i] = make([]string, mField, mField)

		if i <= nField/2 {
			prefix--
		}
		if i > nField/2 {
			prefix++
		}

		for j := 0; j < len(HexField[i]); j++ {
			if i == 0 && j < prefix {
				HexField[i][j] = ` `
			}
			if i == 0 && prefix <= j && j <= mField-1-prefix {
				HexField[i][j] = `_`
			}
			if 0 < i && i <= nField/2 {
				if j < prefix {
					HexField[i][j] = ` `
				}
				if j == prefix {
					HexField[i][j] = `/`
				}
				if prefix < j && j < mField-1-prefix {
					HexField[i][j] = ` `
				}
				if j == mField-1-prefix {
					HexField[i][j] = `\`
				}
			}
			if i > nField/2 {
				if j < prefix-1 {
					HexField[i][j] = ` `
				}
				if j == prefix-1 {
					HexField[i][j] = `\`
				}
				if prefix-1 < j && j < mField-prefix {
					HexField[i][j] = ` `
				}
				if j == mField-prefix {
					HexField[i][j] = `/`
				}
				if i == len(HexField)-1 && j < prefix-1 {
					HexField[i][j] = ` `
				}
				if i == len(HexField)-1 && prefix-1 < j && j < mField-prefix {
					HexField[i][j] = `_`
				}
			}
			if HexField[i][j] == `` {
				HexField[i][j] = ` `
			}
		}
	}
}

// completeDisplay инициирует начальный экран с рамкой
func completeDisplay(n, m, width, height, k int) {

	// задаём массив по размерам экрана с рамкой
	Display = make([][]string, n+2, n+2)
	// рисуем рамку
	for i := 0; i < n+2; i++ {
		Display[i] = make([]string, m+2, m+2)
		for j := 0; j < m+2; j++ {
			// если по углам экрана
			if (i == 0 && j == 0) || (i == 0 && j == len(Display[i])-1) || (i == len(Display)-1 && j == 0) || (i == len(Display)-1 && j == len(Display[i])-1) {
				Display[i][j] = `+`
			}
			// если в верхней или нижней строке
			if (i == 0 && 0 < j && j < len(Display[i])-1) || (i == len(Display)-1 && 0 < j && j < len(Display[i])-1) {
				Display[i][j] = `-`
			}
			// если в центральной части экрана
			if 0 < i && i < len(Display)-1 && 0 < j && j < len(Display[i])-1 {
				Display[i][j] = ` `
			}
			// если в крайних столбцах
			if (0 < i && i < len(Display)-1 && j == 0) || (0 < i && i < len(Display)-1 && j == len(Display[i])-1) {
				Display[i][j] = `|`
			}
		}
	}

	// начальные координаты для отрисовки шестиугольника согласно условиям задачи
	x := 1
	y := 1

	// определим шаг расстановки шестиугольников по вертикали
	deltaX := height
	// определим шаг расстановки шестиугольников по горизонтали в нечётных рядах
	deltaYone := 2 * (height + width)
	// определим шаг расстановки шестиугольников по горизонтали в чётных рядах
	deltaYtwo := height + width

	// заполняем дисплей шестиугольниками по нечётным рядам
	for i := x; i+2*deltaX < len(Display)-1; i += 2 * deltaX {
		for j := y; j <= (len(Display[i])-1)-(2*height+width); j += deltaYone {
			if k != 0 {
				hexToDisplay(i, j)
				k--
			}
		}
	}
	// заполняем дисплей шестиугольниками по чётным рядам
	for i := x + deltaX; i+2*deltaX < len(Display)-1; i += 2 * deltaX {
		for j := y + deltaYtwo; j <= (len(Display[i])-1)-(2*height+width); j += deltaYone {
			if k != 0 {
				hexToDisplay(i, j)
				k--
			}
		}
	}
}

// hexToDisplay рисует на экране (определённом в initDisplay) шестиугольник с заданными координатами
func hexToDisplay(x, y int) {

	for i := 0; i < len(HexField); i++ {
		for j := 0; j < len(HexField[i]); j++ {
			if HexField[i][j] != " " {
				Display[i+x][j+y] = HexField[i][j]
			}
		}
	}
}

// outputing выводит результат
func outputing(out *bufio.Writer, arr [][]string) {

	for i := 0; i < len(arr); i++ {
		for j := 0; j < len(arr[i]); j++ {
			fmt.Fprintf(out, "%s", arr[i][j])
		}
		fmt.Fprint(out, "\n")
	}
}

func main() {

	scanner := bufio.NewScanner(os.Stdin)
	scanner.Split(bufio.ScanLines)

	out := bufio.NewWriter(os.Stdout)
	defer out.Flush()

	// определяем входные данные
	m, n, width, height, k := inputing(scanner)

	// рисуем на единичном поле один шестиугольник
	completeHexField(width, height)

	// определяем экран с рамкой и сеткой шестиугольников
	completeDisplay(n, m, width, height, k)

	// выводим результат
	outputing(out, Display)
}
