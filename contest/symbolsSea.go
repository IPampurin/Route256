/*
Условие задачи
В Nozo разрабатывается новая компьютерная игра — «Колонизация 8». Вам поручено реализовать генератор игровых карт.
Поле игры состоит из шестиугольников, которыми можно полностью покрыть бесконечную плоскость.
Все шестиугольники на поле игры делятся на 2 типа — суша и море. Каждый шестиугольник, у которого есть 6 сторон у которого есть 6 сторон, считается сушей.
Остальные шестиугольники — морем. Вам дана таблица из символов, состоящая из n строк. Каждая строка содержит m символов.
Границы шестиугольников обозначаются символами «\» — обратный слеш, «/» — прямой слеш и «_» — нижнее подчёркивание. Остальные символы поля — пробелы.
Все шестиугольники на поле имеют одинаковый размер. Обозначим за ширину шестиугольника количество подряд идущих символов «_» в его верхней и нижней сторонах.
Аналогично назовём высотой шестиугольника количество символов «/» в левой верхней и правой нижней сторонах.
Замените на символы тильды «~» все пробелы, которые:
• относятся к шестиугольникам моря;
• находятся на границах поля, т.е. на неполных шестиугольниках.

Входные данные
Каждый тест состоит из нескольких наборов входных данных.
Первая строка каждого теста содержит целое число t (1≤t≤100) — количество наборов входных данных.
Далее следует описание наборов входных данных.
Первая строка каждого набора входных данных содержит два целых числа m (3≤n,m≤100) — количество строк и столбцов, из которых состоит поле.
Следующие n строк каждого набора входных данных содержат по m символов — поле с шестиугольниками.

Гарантируется:
• В первой и последней строках, а также в первом и последнем столбцах есть хотя бы один непробельный символ. Следовательно, в этом поле есть хотя бы один шестиугольник суши.
• В этой таблице символов некоторые пробелы можно заменить на символы «_», «/», «\» так, чтобы получилась регулярная сетка из шестиугольников одинакового размера.
Высота и ширина каждого шестиугольника не больше 10.

Выходные данные
Для каждого набора входных данных выведите поле, в котором символы, гарантировано не относящиеся ни к какому из шестиугольников, заменены на символ «~».
После вывода ответа на каждый набор входных данных выведите пустую строку.

Пример теста 1
Входные данные

4
3 3
 _
/ \
\_/
4 9
 _   _
/ \_/ \_
\_/ \_/ \
  \_/ \_/
12 11
     _   _
   _/ \_/ \
  / \_/ \_/
  \_/ \_/
 _/ \_/ \_
/ \_/ \_/ \
\_/ \_/ \_/
/ \ / \
\_/ \_/  _
/ \_/ \ / \
\_/ \_/ \_/
  \_/
5 5
   _
 _/ \
/ \_/
\_/ \
  \_/
Выходные данные

~_~
/ \
\_/

~_~~~_~~~
/ \_/ \_~
\_/ \_/ \
~~\_/~\_/

~~~~~_~~~_~
~~~_/ \_/ \
~~/ \_/ \_/
~~\_/ \_/~~
~_/ \_/ \_~
/ \_/ \_/ \
\_/~\_/~\_/
/ \~/ \~~~~
\_/~\_/~~_~
/ \_/ \~/ \
\_/ \_/~\_/
~~\_/~~~~~~

~~~_~
~_/ \
/ \_/
\_/ \
~~\_/

Пример теста 2
Входные данные

3
5 5
  _
 / \
/   \
\   /
 \_/
6 7
 __
/  \__
\__/  \
/  \__/
\__/  \
   \__/
12 16
 ____      ____
/    \____/    \
\____/    \____/
     \____/
 ____      ____
/    \    /    \
\____/    \____/

 ____
/    \____
\____/    \
     \____/
Выходные данные

~~_~~
~/ \~
/   \
\   /
~\_/~

~__~~~~
/  \__~
\__/  \
/  \__/
\__/  \
~~~\__/

~____~~~~~~____~
/    \____/    \
\____/    \____/
~~~~~\____/~~~~~
~____~~~~~~____~
/    \~~~~/    \
\____/~~~~\____/
~~~~~~~~~~~~~~~~
~____~~~~~~~~~~~
/    \____~~~~~~
\____/    \~~~~~
~~~~~\____/~~~~~

*/

package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
)

func inputCalc(sc *bufio.Scanner, out *bufio.Writer) {

	// считываем количество групп данных
	sc.Scan()
	groupCount, err := strconv.Atoi(sc.Text())
	if err != nil {
		log.Fatal(err)
	}

	// считываем и обрабатываем данные по группам
	for group := 1; group <= groupCount; group++ {

		// считываем количество строк и столбцов
		sc.Scan()
		nWithm := strings.Split(sc.Text(), " ")
		n, err := strconv.Atoi(nWithm[0])
		m, err := strconv.Atoi(nWithm[1])
		if err != nil {
			log.Fatal(err)
		}

		// поле для отображения карты
		field := fieldInit(n, m)

		// построчно сканируем ввод и посимвольно вписываем в field
		for i := 0; i < len(field); i++ {
			//stack := ""
			sc.Scan()
			for j, val := range sc.Text() {
				if string(val) != " " {
					field[i][j] = string(val)
				}
			}
		}

		delTildaExcess(field)

		// выводим поле по группе
		outputing(out, field)
	}
}

// fieldInit инициализирует символами "~" поле для заполнения его шестиугольниками
func fieldInit(n, m int) [][]string {

	// поле для отображения карты
	field := make([][]string, n, n)

	for i := 0; i < len(field); i++ {
		field[i] = make([]string, m, m)
		for j := 0; j < len(field[i]); j++ {
			field[i][j] = "~"
		}
	}

	return field
}

/*
	delTildaExcess убирает лишние знаки ~ для частичного решения задачи - когда шестиугольники имеют следующий вид:

`_
/ \
\_/
`
*/
func delTildaExcess(arr [][]string) {

	for i := 0; i < len(arr); i++ {
		for j := 0; j < len(arr[i]); j++ {

			if i != 0 && i != len(arr)-1 && j != 0 && j != len(arr[i])-1 {
				if arr[i][j] == "~" &&
					arr[i-1][j] == "_" && arr[i+1][j] == "_" &&
					arr[i][j-1] == "/" && arr[i][j+1] == "\\" &&
					arr[i+1][j-1] == "\\" && arr[i+1][j+1] == "/" {

					arr[i][j] = " "
				}
			}
		}
	}
}

// outputing выводит результат
func outputing(out *bufio.Writer, arr [][]string) {

	for i := 0; i < len(arr); i++ {
		for j := 0; j < len(arr[i]); j++ {
			fmt.Fprintf(out, "%s", arr[i][j])
		}
		fmt.Fprint(out, "\n")
	}
	fmt.Fprint(out, "\n")
}

func main() {

	// определяем ввод
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Split(bufio.ScanLines)

	// определяем вывод
	out := bufio.NewWriter(os.Stdout)
	defer out.Flush()

	inputCalc(scanner, out)
}
