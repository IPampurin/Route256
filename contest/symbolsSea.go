/*
Условие задачи
В Nozo разрабатывается новая компьютерная игра — «Колонизация 8». Вам поручено реализовать генератор игровых карт.
Поле игры состоит из шестиугольников, которыми можно полностью покрыть бесконечную плоскость.
Все шестиугольники на поле игры делятся на 2 типа — суша и море. Каждый шестиугольник, у которого есть 6 сторон у которого есть 6 сторон, считается сушей.
Остальные шестиугольники — морем. Вам дана таблица из символов, состоящая из n строк. Каждая строка содержит m символов.
Границы шестиугольников обозначаются символами «\» — обратный слеш, «/» — прямой слеш и «_» — нижнее подчёркивание. Остальные символы поля — пробелы.
Все шестиугольники на поле имеют одинаковый размер. Обозначим за ширину шестиугольника количество подряд идущих символов «_» в его верхней и нижней сторонах.
Аналогично назовём высотой шестиугольника количество символов «/» в левой верхней и правой нижней сторонах.
Замените на символы тильды «~» все пробелы, которые:
• относятся к шестиугольникам моря;
• находятся на границах поля, т.е. на неполных шестиугольниках.

Входные данные
Каждый тест состоит из нескольких наборов входных данных.
Первая строка каждого теста содержит целое число t (1≤t≤100) — количество наборов входных данных.
Далее следует описание наборов входных данных.
Первая строка каждого набора входных данных содержит два целых числа m (3≤n,m≤100) — количество строк и столбцов, из которых состоит поле.
Следующие n строк каждого набора входных данных содержат по m символов — поле с шестиугольниками.

Гарантируется:
• В первой и последней строках, а также в первом и последнем столбцах есть хотя бы один непробельный символ. Следовательно, в этом поле есть хотя бы один шестиугольник суши.
• В этой таблице символов некоторые пробелы можно заменить на символы «_», «/», «\» так, чтобы получилась регулярная сетка из шестиугольников одинакового размера.
Высота и ширина каждого шестиугольника не больше 10.

Выходные данные
Для каждого набора входных данных выведите поле, в котором символы, гарантировано не относящиеся ни к какому из шестиугольников, заменены на символ «~».
После вывода ответа на каждый набор входных данных выведите пустую строку.

Пример теста 1
Входные данные

4
3 3
 _
/ \
\_/
4 9
 _   _
/ \_/ \_
\_/ \_/ \
  \_/ \_/
12 11
     _   _
   _/ \_/ \
  / \_/ \_/
  \_/ \_/
 _/ \_/ \_
/ \_/ \_/ \
\_/ \_/ \_/
/ \ / \
\_/ \_/  _
/ \_/ \ / \
\_/ \_/ \_/
  \_/
5 5
   _
 _/ \
/ \_/
\_/ \
  \_/
Выходные данные

~_~
/ \
\_/

~_~~~_~~~
/ \_/ \_~
\_/ \_/ \
~~\_/~\_/

~~~~~_~~~_~
~~~_/ \_/ \
~~/ \_/ \_/
~~\_/ \_/~~
~_/ \_/ \_~
/ \_/ \_/ \
\_/~\_/~\_/
/ \~/ \~~~~
\_/~\_/~~_~
/ \_/ \~/ \
\_/ \_/~\_/
~~\_/~~~~~~

~~~_~
~_/ \
/ \_/
\_/ \
~~\_/

Пример теста 2
Входные данные

3
5 5
  _
 / \
/   \
\   /
 \_/
6 7
 __
/  \__
\__/  \
/  \__/
\__/  \
   \__/
12 16
 ____      ____
/    \____/    \
\____/    \____/
     \____/
 ____      ____
/    \    /    \
\____/    \____/

 ____
/    \____
\____/    \
     \____/
Выходные данные

~~_~~
~/ \~
/   \
\   /
~\_/~

~__~~~~
/  \__~
\__/  \
/  \__/
\__/  \
~~~\__/

~____~~~~~~____~
/    \____/    \
\____/    \____/
~~~~~\____/~~~~~
~____~~~~~~____~
/    \~~~~/    \
\____/~~~~\____/
~~~~~~~~~~~~~~~~
~____~~~~~~~~~~~
/    \____~~~~~~
\____/    \~~~~~
~~~~~\____/~~~~~

*/

package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
)

func inputCalc(sc *bufio.Scanner, out *bufio.Writer) {

	// считываем количество групп данных
	sc.Scan()
	groupCount, err := strconv.Atoi(sc.Text())
	if err != nil {
		log.Fatal(err)
	}

	// считываем и обрабатываем данные по группам
	for group := 1; group <= groupCount; group++ {

		// считываем количество строк и столбцов
		sc.Scan()
		nWithm := strings.Split(sc.Text(), " ")
		n, err := strconv.Atoi(nWithm[0])
		m, err := strconv.Atoi(nWithm[1])
		if err != nil {
			log.Fatal(err)
		}

		// в coordinates будем запоминать координаты начала шестиугольников в сетке
		coordinates := make([]struct{ x, y int }, 0)

		// поле для отображения карты
		field := make([][]string, n, n)

		// построчно сканируем ввод и посимвольно вписываем в field, все пробелы меняя на ~
		for i := 0; i < len(field); i++ {
			field[i] = make([]string, m, m)
			sc.Scan()

			for j, val := range sc.Text() {
				if string(val) != " " {
					field[i][j] = string(val)
				} else {
					field[i][j] = "~"
				}
				// если попадается признак левой оконечности шестиугольника, запоминаем координаты для последующей обработки
				if i > 0 && field[i][j] == "\\" && field[i-1][j] == "/" {
					coordinates = append(coordinates, struct{ x, y int }{x: i, y: j})
				}
			}
		}

		// height полувысота шестиугольника, width длина основания шестиугольника
		// определяем параметры сетки шестиугольников исходя из предположения, что на поле есть хотя бы один шестиугольник
		height, width := sizeHex(coordinates[0].x, coordinates[0].y, &field)

		// проходим по координатам вершин предполагаемых шестиугольников и после валидации рисуем "сушу"
		for _, point := range coordinates {
			if validHex(height, width, point.x, point.y, &field) {
				hexPrint(height, width, point.x, point.y, &field)
			}
		}

		// выводим поле по группе
		outputing(out, field)
	}
}

// sizeHex определяет параметры шестиугольной сетки в нашем специально обученном массиве
func sizeHex(x, y int, field *[][]string) (int, int) {

	x--    // перемещаемся на нижний левый элемент верхней крышки шестиугольника
	h := 1 // полувысота в этом случае == 1
	// шагаем вверх по левой стороне крышки шестиугольника пока не нащупаем самый верх
	for (*field)[x-1][y+1] != "_" {
		h++
		x--
		y++
	}

	// перемещаемся на крайний левый элемент верха крышки шестиугольника
	x--
	y++
	// в этом случае длина основания шестиугольника == 0
	w := 0
	// шагаем вправо по верху крышки шестиугольника пока не нащупаем её край
	for (*field)[x][y] == "_" {
		w++
		y++
	}

	return h, w
}

// hexPrint рисует заполненный пробелами шестиугольник с заданными размерами по заданным координатам в специально обученном массиве
func hexPrint(h, w, x, y int, field *[][]string) {

	// если при отрисовке шестиугольника есть выход за границы массива, то ничего не рисуем
	if y+2*h+w-1 > len((*field)[0])-1 {
		return
	}

	prefix := -1
	// рисуем крышку
	for i := x - 1; i >= x-h-1; i-- {
		prefix++
		for j := y; j <= y+2*h+w; j++ {
			if i != x-h-1 && j == y+prefix {
				(*field)[i][j] = "/"
			}
			if i != x-h-1 && y+prefix < j && j < y+2*h+w-prefix {
				(*field)[i][j] = " "
			}
			if i != x-h-1 && j == y+2*h+w-1-prefix {
				(*field)[i][j] = "\\"
			}
			if i == x-h-1 && y+prefix <= j && j <= y+2*h+w-1-prefix {
				(*field)[i][j] = "_"
			}
		}
	}
	// рисуем донышко
	prefix = -1
	for i := x; i <= x+h-1; i++ {
		prefix++
		for j := y; j <= y+2*h+w; j++ {
			if j == y+prefix {
				(*field)[i][j] = "\\"
			}
			if i != x+h-1 && y+prefix < j && j < y+2*h+w-prefix {
				(*field)[i][j] = " "
			}
			if j == y+2*h+w-1-prefix {
				(*field)[i][j] = "/"
			}
			if i == x+h-1 && y+prefix < j && j < y+2*h+w-1-prefix {
				(*field)[i][j] = "_"
			}
		}
	}
}

// validHex проверяет наличие всех шести сторон шестиугольника определённых размеров по заданным координатам в массиве
func validHex(h, w, x, y int, field *[][]string) bool {

	// если при проверке шестиугольника есть выход за границы массива, то ничего не рисуем
	if y+2*h+w-1 > len((*field)[0])-1 {
		return false
	}

	prefix := -1
	// проверяем крышку
	for i := x - 1; i >= x-h-1; i-- {
		prefix++
		for j := y; j <= y+2*h+w; j++ {
			if i != x-h-1 && j == y+prefix {
				if (*field)[i][j] != "/" {
					return false
				}
			}
			if i != x-h-1 && j == y+2*h+w-1-prefix {
				if (*field)[i][j] != "\\" {
					return false
				}
			}
			if i == x-h-1 && y+prefix <= j && j <= y+2*h+w-1-prefix {
				if (*field)[i][j] != "_" {
					return false
				}
			}
		}
	}
	// проверяем донышко
	prefix = -1
	for i := x; i <= x+h-1; i++ {
		prefix++
		for j := y; j <= y+2*h+w; j++ {
			if j == y+prefix {
				if (*field)[i][j] != "\\" {
					return false
				}
			}
			if j == y+2*h+w-1-prefix {
				if (*field)[i][j] != "/" {
					return false
				}
			}
			if i == x+h-1 && y+prefix < j && j < y+2*h+w-1-prefix {
				if (*field)[i][j] != "_" {
					return false
				}
			}
		}
	}

	return true
}

// outputing выводит результат
func outputing(out *bufio.Writer, arr [][]string) {

	for i := 0; i < len(arr); i++ {
		for j := 0; j < len(arr[i]); j++ {
			fmt.Fprintf(out, "%s", arr[i][j])
		}
		fmt.Fprint(out, "\n")
	}
	fmt.Fprint(out, "\n")
}

func main() {

	// определяем ввод
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Split(bufio.ScanLines)

	// определяем вывод
	out := bufio.NewWriter(os.Stdout)
	defer out.Flush()

	inputCalc(scanner, out)
}
